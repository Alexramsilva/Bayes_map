# -*- coding: utf-8 -*-
"""Bayes_Map.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhrwNAbIGuvUWx06AbPJqtgEEat0cTd3
"""

import streamlit as st
import yfinance as yf
import pandas as pd

st.title("Ranking Bayesiano: TOP 30 Acciones con Mayor Probabilidad de Subida")

acciones = [
"^GSPC","BTC-USD", "NVDA", "BABA", "VISTAA.MX", "DANHOS13.MX", "EDUCA18.MX",
"FIBRAMQ12.MX", "FIBRAPL14.MX", "FIHO12.MX", "FINN13.MX", "FMTY14.MX",
"FPLUS16.MX", "FSHOP13.MX", "FUNO11.MX", "ACCELSAB.MX", "AGUA.MX", "ALFAA.MX",
"ASURB.MX", "CADUA.MX", "CERAMICB.MX", "DINEB.MX", "GAPB.MX", "GCARSOA1.MX",
"GISSAA.MX", "GMD.MX", "GMXT.MX", "HOMEX.MX", "JAVER.MX", "KUOB.MX",
"OMAB.MX", "ORBIA.MX", "PASAB.MX", "PINFRAL.MX", "SITES1A-1.MX", "TMMA.MX",
"TRAXIONA.MX", "VESTA.MX", "VINTE.MX", "VOLARA.MX", "ALPEKA.MX", "AUTLANB.MX",
"CEMEXCPO.MX", "CMOCTEZ.MX", "COLLADO.MX", "CONVERA.MX", "CYDSASAA.MX",
"GCC.MX", "GMEXICOB.MX", "ICHB.MX", "LAMOSA.MX", "MFRISCOA-1.MX",
"PE&OLES.MX", "POCHTECB.MX", "SIMECB.MX", "TEAKCPO.MX", "VITROA.MX",
"AC.MX", "BIMBOA.MX", "CHDRAUIB.MX", "CUERVO.MX", "CULTIBAB.MX",
"FEMSAUBD.MX", "GIGANTE.MX", "GRUMAB.MX", "HERDEZ.MX", "KIMBERA.MX",
"KOFUBL.MX", "LACOMERUBC.MX", "MINSAB.MX", "SORIANAB.MX", "WALMEX.MX",
"BEVIDESB.MX", "FRAGUAB.MX", "LABB.MX", "MEDICAB.MX", "AMXB.MX",
"AXTELCPO.MX", "CABLECPO.MX", "CTAXTELA.MX", "MEGACPO.MX", "TLEVISACPO.MX",
"ACTINVRB.MX", "BBAJIOO.MX", "BOLSAA.MX", "CREAL.MX", "FINAMEXO.MX",
"FINDEP.MX", "GBMO.MX", "GENTERA.MX", "GFINBURO.MX", "GFNORTEO.MX",
"GNP.MX", "GPROFUT.MX", "INVEXA.MX", "PROCORPB.MX", "Q.MX", "RA.MX",
"AGUILASCPO.MX", "ALSEA.MX", "CIDMEGA.MX", "CIEB.MX", "CMRB.MX",
"HCITY.MX", "HOTEL.MX", "LIVEPOL1.MX", "NEMAKA.MX", "POSADASA.MX",
"RLHA.MX", "SPORTS.MX", "VASCONI.MX", "ARKB", "BTCW", "BTCO", "BITB",
"HODL", "EZBC", "FBTC", "BRRR", "GBTC", "DEFI", "IBIT", "ACWI",
"SPY", "FAS", "SPXL", "TECL", "IAU", "NU", "MELI", "META",
"NFLX", "IONQ", "QUBT", "QBTS", "RGTI", "PLTR", "SOFI", "HOOD",
]

st.info("Calculando probabilidades… Esto puede tardar 5–20 segundos según tu conexión.")

resultados = []

for ticker in acciones:
    try:
        data = yf.download(ticker, period="1mo", interval="1d")

        if data.empty:
            continue

        # Medias móviles
        data["MA5"] = data["Close"].rolling(5).mean()
        data["MA10"] = data["Close"].rolling(10).mean()
        data["Signal"] = (data["MA5"] > data["MA10"]).astype(int)

        # Rendimiento diario
        data["Return"] = data["Close"].pct_change()
        data["Up"] = (data["Return"] > 0).astype(int)

        # Probabilidades
        p_up = data["Up"].mean()
        p_down = 1 - p_up

        p_signal_given_up = data[data["Up"] == 1]["Signal"].mean()
        p_signal_given_down = data[data["Up"] == 0]["Signal"].mean()

        p_signal = p_signal_given_up * p_up + p_signal_given_down * p_down

        p_up_given_signal = 0
        if p_signal > 0:
            p_up_given_signal = (p_signal_given_up * p_up) / p_signal

        resultados.append([ticker, p_up_given_signal])

    except Exception as e:
        st.write(f"Error con {ticker}: {e}")

# Ranking final
df = pd.DataFrame(resultados, columns=["Accion", "P(Subida|Señal)"])
df = df.sort_values(by="P(Subida|Señal)", ascending=False).reset_index(drop=True)

top30 = df.head(30)

st.subheader("TOP 30 Acciones con Mayor Probabilidad de Subida (Bayes)")
st.dataframe(top30)

# Exportar CSV
csv = top30.to_csv(index=False).encode("utf-8")

st.download_button("Descargar TOP 30 en CSV", csv, "top30_bayes.csv")


# -----------------------------------------------------
# SEGUNDO CÓDIGO
# -----------------------------------------------------

st.write(f"Descargando datos de **{ticker}**...")

df = yf.download(ticker, period="2y", interval="1d")

if df.empty:
    st.error("No hay datos disponibles.")
    st.stop()

# CÁLCULOS
df["MA5"] = df["Close"].rolling(5).mean()
df["MA10"] = df["Close"].rolling(10).mean()
df.dropna(inplace=True)

df["Signal"] = np.where(df["MA5"] > df["MA10"], 1, 0)
df["Crossover"] = df["Signal"].diff()

# MODELO DE HOOKE
close_values = df["Close"].values.flatten()
ma10_values = df["MA10"].values.flatten()

df["x"] = close_values - ma10_values
k = 0.001
df["Force"] = -k * df["x"]

threshold = df["x"].std() * 1.5
df["Exit"] = np.where(abs(df["x"]) > threshold, 1, 0)

# GRÁFICO PRINCIPAL
fig, ax1 = plt.subplots(figsize=(14, 7))

ax1.plot(df["Close"], label="Precio", color="black", linewidth=1)
ax1.plot(df["MA10"], label="Media móvil (equilibrio)", color="orange")

ax1.fill_between(
    df.index,
    df["MA10"] - threshold,
    df["MA10"] + threshold,
    color="green",
    alpha=0.2,
    label="Zona elástica (Hooke)"
)

df["Exit_diff"] = df["Exit"].diff()
exit_dates = df[(df["Exit_diff"] == 1) & (df["MA5"] > df["MA10"])].index
entry_dates = df[(df["Exit_diff"] == -1) & (df["MA5"] < df["MA10"])].index

for date in exit_dates:
    ax1.axvline(x=date, color="red", linestyle="--", alpha=0.5)
    ax1.text(date, df["Close"].max(), "S", color="red", fontsize=8, rotation=90, va="top")

for date in entry_dates:
    ax1.axvline(x=date, color="green", linestyle="--", alpha=0.5)
    ax1.text(date, df["Close"].min(), "E", color="green", fontsize=8, rotation=90, va="bottom")

ax1.set_xlabel("Fecha")
ax1.set_ylabel("Precio")
ax1.grid(True)
ax1.legend(loc="upper left")

ax2 = ax1.twinx()
ax2.plot(df["Force"], label="Fuerza (-k*x)", color="blue", linestyle="--", alpha=0.7)
ax2.set_ylabel("Fuerza (k*x)")
ax2.legend(loc="lower left")

plt.title(f"Modelo del Resorte de Hooke aplicado al precio de {ticker}")

st.pyplot(fig)


